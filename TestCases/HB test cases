/* FreeRTOS 8.2 Tiva Demo
 *
 * main.c
 *
 * Andy Kobyljanec
 *
 * This is a simple demonstration project of FreeRTOS 8.2 on the Tiva Launchpad
 * EK-TM4C1294XL.  TivaWare driverlib source code is included.
 */

#include <stdint.h>
#include <stdbool.h>
#include "main.h"
#include "drivers/pinout.h"
#include "utils/uartstdio.h"
#include "I2C_new.h"
#include "EEPROMdriver.h"
// TivaWare includes
#include "driverlib/sysctl.h"
#include "driverlib/debug.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "inc/hw_memmap.h"
#include "inc/hw_ints.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/uart.h"
#include "utils/ustdlib.h"

#include "utils/lwiplib.h"
#include "utils/locator.h"
#include "lwip/opt.h"
// FreeRTOS includes
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "gesture_sensor.h"
#include "messaging.h"

#define LSM6DS3_ADDR        (0x6A)
#define TMP102_ADDR         (0x48)


// Global instance structure for the I2C master driver.
//tI2CMInstance g_sI2CInst;

uint32_t g_ui32SysClock;
uint32_t g_ui32IPAddress;


// Demo Task declarations
void HeartBeatChecker(void *pvParameters);
void SensorTask(void *pvParameters);
void LCDTask(void *pvParameters);
void EEPROMTask(void *pvParameters);

SemaphoreHandle_t UartProtector;

TaskHandle_t TaskHandle[TOTAL_NUMBER_OF_TASKS];

QueueHandle_t QueueHandle[TOTAL_NUMBER_OF_TASKS-1];


//*****************************************************************************
//
// Display an lwIP type IP Address.
//
//*****************************************************************************
void
DisplayIPAddress(uint32_t ui32Addr)
{
    char pcBuf[16];

    //
    // Convert the IP Address into a string.
    //
    usprintf(pcBuf, "%d.%d.%d.%d", ui32Addr & 0xff, (ui32Addr >> 8) & 0xff,
            (ui32Addr >> 16) & 0xff, (ui32Addr >> 24) & 0xff);

    //
    // Display the string.
    //
    UARTprintf(pcBuf);
}

void
lwIPHostTimerHandler(void)
{
    uint32_t ui32Idx, ui32NewIPAddress;

    //
    // Get the current IP address.
    //
    ui32NewIPAddress = lwIPLocalIPAddrGet();

    //
    // See if the IP address has changed.
    //
    if(ui32NewIPAddress != g_ui32IPAddress)
    {
        //
        // See if there is an IP address assigned.
        //
        if(ui32NewIPAddress == 0xffffffff)
        {
            //
            // Indicate that there is no link.
            //
            UARTprintf("Waiting for link.\n");
        }
        else if(ui32NewIPAddress == 0)
        {
            //
            // There is no IP address, so indicate that the DHCP process is
            // running.
            //
            UARTprintf("Waiting for IP address.\n");
        }
        else
        {
            //
            // Display the new IP address.
            //
            UARTprintf("IP Address: ");
            DisplayIPAddress(ui32NewIPAddress);
            UARTprintf("\nOpen a browser and enter the IP address.\n");
        }

        //
        // Save the new IP address.
        //
        g_ui32IPAddress = ui32NewIPAddress;

        //
        // Turn GPIO off.
        //
        MAP_GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_1, ~GPIO_PIN_1);
    }

    //
    // If there is not an IP address.
    //
    if((ui32NewIPAddress == 0) || (ui32NewIPAddress == 0xffffffff))
    {
        //
        // Loop through the LED animation.
        //

        for(ui32Idx = 1; ui32Idx < 17; ui32Idx++)
        {

            //
            // Toggle the GPIO
            //
            MAP_GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_1,
                    (MAP_GPIOPinRead(GPIO_PORTN_BASE, GPIO_PIN_1) ^
                     GPIO_PIN_1));

            SysCtlDelay(g_ui32SysClock/(ui32Idx << 1));
        }
    }
}

//*****************************************************************************
//
// The interrupt handler for the SysTick interrupt.
//
//*****************************************************************************
void
SysTickIntHandler(void)
{
    //
    // Call the lwIP timer handler.
    //
    lwIPTimer(SYSTICKMS);
}
 err_t connection_successful(void *arg, struct tcp_pcb *tpcb, err_t err)
 {
     UARTprintf("Connection hogaya\n");
     return 0;
 }

// Main function
int main(void)
{
    uint32_t ui32User0, ui32User1;

    uint8_t pui8MACArray[8];

    // Initialize system clock to 120 MHz

    g_ui32SysClock = ROM_SysCtlClockFreqSet(
                               (SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN |
                                SYSCTL_USE_PLL | SYSCTL_CFG_VCO_480),
                               SYSTEM_CLOCK);
    ASSERT(g_ui32SysClock == SYSTEM_CLOCK);

    // Set up the UART which is connected to the virtual COM port
    UARTStdioConfig(0, 57600, SYSTEM_CLOCK);

    // Initialize the GPIO pins for the Launchpad
    PinoutSet(true, false);

    //
    // Configure SysTick for a periodic interrupt.
    //
    MAP_SysTickPeriodSet(g_ui32SysClock / SYSTICKHZ);
    MAP_SysTickEnable();
    MAP_SysTickIntEnable();


    //
    // Configure the hardware MAC address for Ethernet Controller filtering of
    // incoming packets.  The MAC address will be stored in the non-volatile
    // USER0 and USER1 registers.
    //
    MAP_FlashUserGet(&ui32User0, &ui32User1);
    if((ui32User0 == 0xffffffff) || (ui32User1 == 0xffffffff))
    {
        //
        // We should never get here.  This is an error if the MAC address has
        // not been programmed into the device.  Exit the program.
        // Let the user know there is no MAC address
        //
        UARTprintf("No MAC programmed!\n");
        while(1)
        {
        }
    }

    //
    // Tell the user what we are doing just now.
    //
    UARTprintf("Waiting for IP.\n");

    //
    // Convert the 24/24 split MAC address from NV ram into a 32/16 split MAC
    // address needed to program the hardware registers, then program the MAC
    // address into the Ethernet Controller registers.
    //
    pui8MACArray[0] = ((ui32User0 >>  0) & 0xff);
    pui8MACArray[1] = ((ui32User0 >>  8) & 0xff);
    pui8MACArray[2] = ((ui32User0 >> 16) & 0xff);
    pui8MACArray[3] = ((ui32User1 >>  0) & 0xff);
    pui8MACArray[4] = ((ui32User1 >>  8) & 0xff);
    pui8MACArray[5] = ((ui32User1 >> 16) & 0xff);

    //
    // Initialize the lwIP library, using DHCP.
    //
    //lwIPInit(g_ui32SysClock, pui8MACArray, 0xC0A80703, 0xFFFFFF00,  0xC0A80702, IPADDR_USE_STATIC);
    //lwIPInit(g_ui32SysClock, pui8MACArray, 0, 0, 0, IPADDR_USE_STATIC);
    //
    // Setup the device locator service.
    //
    //LocatorInit();
    //LocatorMACAddrSet(pui8MACArray);
    //LocatorAppTitleSet("EK-TM4C1294XL enet_io");

    /* create a socket */
    struct tcp_pcb *client_pcb_socket;
    err_t err;
    client_pcb_socket = tcp_new();
    LWIP_ASSERT("socket_init: tcp_new failed", client_pcb_socket != NULL);

    uint32_t remote_ip=0xC0A80702;

    err_t connect_return = tcp_connect(client_pcb_socket, &remote_ip, 1025, connection_successful );

    LWIP_ASSERT("socket_init: tcp_connect failed", connect_return != NULL);

    /* initialize callback arg and accept callback */
   // tcp_arg(client_pcb_socket, pcb);

    //tcp_accept(pcb, http_accept);
    BaseType_t xTaskCreateReturn;

    UartProtector=xSemaphoreCreateMutex();

    /* Create all the tasks required */
    /* send the heart beat task's handle info as an argument */
    xTaskCreateReturn=xTaskCreate(HeartBeatChecker, (const portCHAR *)"HeartBeat",
                   configMINIMAL_STACK_SIZE, NULL, 1, &TaskHandle[HEARTBEAT_TASK] );

    UARTprintf("\r\nHB handle val:%d", TaskHandle[HEARTBEAT_TASK]);

    if(xTaskCreateReturn==errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
        UARTprintf("\r\nHB task creation failed");

    xTaskCreateReturn=xTaskCreate(SensorTask, (const portCHAR *)"Sensor",
                configMINIMAL_STACK_SIZE, NULL, 2, &TaskHandle[SENSOR_TASK]);

    if(xTaskCreateReturn==errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
            UARTprintf("\r\nSensor task creation failed");

    xTaskCreateReturn=xTaskCreate(LCDTask, (const portCHAR *)"LCD",
                configMINIMAL_STACK_SIZE, NULL, 2, &TaskHandle[LCD_TASK]);

    if(xTaskCreateReturn==errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
            UARTprintf("\r\nLCD task creation failed");


    xTaskCreateReturn=xTaskCreate(EEPROMTask, (const portCHAR *)"EEPROM",
                configMINIMAL_STACK_SIZE, NULL, 2, &TaskHandle[EEPROM_TASK]);

    if(xTaskCreateReturn==errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
            UARTprintf("\r\nEEPROM task creation failed");


    /* create Queues for all the above defined tasks except the heart beat task */
    QueueHandle[SENSOR_TASK]=xQueueCreate(QUEUE_LENGTH, sizeof(InterTaskPacket_t));

    /* error checking */
    if( QueueHandle[SENSOR_TASK]== NULL)
        UARTprintf("\r\nSensor Queue creation failed");

    QueueHandle[LCD_TASK]=xQueueCreate(QUEUE_LENGTH, sizeof(InterTaskPacket_t));

    /* error checking */
    if( QueueHandle[LCD_TASK]== NULL)
        UARTprintf("\r\nLCD Queue creation failed");

    QueueHandle[EEPROM_TASK]=xQueueCreate(QUEUE_LENGTH, sizeof(InterTaskPacket_t));

    /* error checking */
    if( QueueHandle[EEPROM_TASK]== NULL)
        UARTprintf("\r\nEEPROM Queue creation failed");


    vTaskStartScheduler();

    return 0;
}

// Flash the LEDs on the launch pad
void HeartBeatChecker(void *pvParameters)
{
    uint32_t HeartbeatReceived;
    BaseType_t NotifyWaitReturn;

    /* get heart beats from the tasks created in this loop */
    while(1)
    {
        vTaskDelay(10000);

        /* clear the bits that need to be set by other tasks on exit and get the value written by other tasks */
        NotifyWaitReturn=xTaskNotifyWait( 0, LCD_TASK_HEARTBEAT|SENSOR_TASK_HEARTBEAT|EEPROM_TASK_HEARTBEAT,
                                  &HeartbeatReceived, pdMS_TO_TICKS(10000) );

        /* Now check if the bits corresponding to each task are set */
        if(!(HeartbeatReceived&LCD_TASK_HEARTBEAT))
        {
            /* let it wait indefinitely until it gets the semaphore;
             * INCLUDE_vTaskSuspend is set to 1 in the FreeRTOSConfig.h file
             * */
            xSemaphoreTake( UartProtector, portMAX_DELAY);
            UARTprintf("\r\nHB from LCD missed");
            xSemaphoreGive(UartProtector);
        }

        if(!(HeartbeatReceived&SENSOR_TASK_HEARTBEAT))
        {
           /* let it wait indefinitely until it gets the semaphore;
            * INCLUDE_vTaskSuspend is set to 1 in the FreeRTOSConfig.h file
            * */
            xSemaphoreTake( UartProtector, portMAX_DELAY);
            UARTprintf("\r\nHB from Sensor missed");
            xSemaphoreGive(UartProtector);
        }
        if(!(HeartbeatReceived&EEPROM_TASK_HEARTBEAT))
        {
           /* let it wait indefinitely until it gets the semaphore;
            * INCLUDE_vTaskSuspend is set to 1 in the FreeRTOSConfig.h file
            * */
            xSemaphoreTake( UartProtector, portMAX_DELAY);
            UARTprintf("\r\nHB from EEPROM missed");
            xSemaphoreGive(UartProtector);
        }

        /* no task is alive */
        if(NotifyWaitReturn==pdFALSE)
        {
           /* let it wait indefinitely until it gets the semaphore;
            * INCLUDE_vTaskSuspend is set to 1 in the FreeRTOSConfig.h file
            * */
            xSemaphoreTake( UartProtector, portMAX_DELAY);
            UARTprintf("\r\nTimed out:Didn't receive anything, notification val:%d", HeartbeatReceived);
            xSemaphoreGive(UartProtector);

            /* TODO: Write to the logger here  or set a flag or something which controls log data or data that's sent to the BBG */

        }
        else
        {
           /* let it wait indefinitely until it gets the semaphore;
            *  INCLUDE_vTaskSuspend is set to 1 in the FreeRTOSConfig.h file
            * */
            xSemaphoreTake( UartProtector, portMAX_DELAY);
            UARTprintf("\r\nNotification val:%d", HeartbeatReceived);
            xSemaphoreGive(UartProtector);
        }

    }
}

/* just flashing some LEDs for now */
void SensorTask(void *pvParameters)
{
    TaskHandle_t HeartBeatHandle=TaskHandle[HEARTBEAT_TASK];

    //BaseType_t TaskNotifyReturn;

    xSemaphoreTake( UartProtector, portMAX_DELAY);
    UARTprintf("\r\nHB handle val in SensorTask:%d", HeartBeatHandle);
    xSemaphoreGive(UartProtector);

    for (;;)
    {
        xSemaphoreTake( UartProtector, portMAX_DELAY);
        /* debug message to the UART logger */
        UARTprintf("\r\nSent HB from SensorTask");
        xSemaphoreGive(UartProtector);

        vTaskDelay(2000);
        /* notify the HeartBeat task of your well being */
        /* OR the notification value with the value that represents this task's heart beat using the esetBits argument */
        /* no point in checking the return from this function as it's always going to return successfully */
        xTaskNotify(HeartBeatHandle, SENSOR_TASK_HEARTBEAT, eSetBits);

    }
}

/* just writing to UART for now */
void LCDTask(void *pvParameters)
{
    /* */
    TaskHandle_t HeartBeatHandle=TaskHandle[HEARTBEAT_TASK];

    xSemaphoreTake(UartProtector, portMAX_DELAY);
    UARTprintf("\r\nHB handle val in LCDTask:%d", HeartBeatHandle);
    xSemaphoreGive(UartProtector);


    for (;;)
    {
        xSemaphoreTake( UartProtector, portMAX_DELAY);
        UARTprintf("\r\nSent HB from LCD");
        xSemaphoreGive(UartProtector);

        vTaskDelay(2000);

        /* notify the HeartBeat task of your well being */
        /* OR the notification value with the value that represents this task's heart beat using the esetBits argument */
        /* no point in checking the return from this function as it's always going to return successfully */
        xTaskNotify(HeartBeatHandle, LCD_TASK_HEARTBEAT, eSetBits);

    }
}

/* reading and writing to addresses for now */
void EEPROMTask(void *pvParameters)
{
    TaskHandle_t HeartBeatHandle=TaskHandle[HEARTBEAT_TASK];

    //BaseType_t TaskNotifyReturn;

    xSemaphoreTake( UartProtector, portMAX_DELAY);
    UARTprintf("\r\nHB handle val in EEPROM Task:%d", HeartBeatHandle);
    xSemaphoreGive(UartProtector);
    uint32_t eeprom_val=0, eeprom_val_read=0;
    uint32_t addr=0x400;

    /* initialize the EEPROM */
    driver_rc eprom_init_return =eeprom_init();

    if(eprom_init_return!=DRIVER_SUCCESS)
    {
        xSemaphoreTake( UartProtector, portMAX_DELAY);
        UARTprintf("\r\nInitialization failed");
        xSemaphoreGive(UartProtector);
    }

    for (;;)
    {
        xSemaphoreTake( UartProtector, portMAX_DELAY);
        /* debug message to the UART logger */
        UARTprintf("\r\nSent HB from EEPROMTask");
        xSemaphoreGive(UartProtector);

        vTaskDelay(2000);

        /* notify the HeartBeat task of your well being */
        /* OR the notification value with the value that represents this task's heart beat using the esetBits argument */
        /* no point in checking the return from this function as it's always going to return successfully */
        xTaskNotify(HeartBeatHandle, EEPROM_TASK_HEARTBEAT, eSetBits);


    }
}

/*  ASSERT() Error function
 *
 *  failed ASSERTS() from driverlib/debug.h are executed in this function
 */
void __error__(char *pcFilename, uint32_t ui32Line)
{
    // Place a breakpoint here to capture errors until logging routine is finished
    while (1)
    {
    }
}

